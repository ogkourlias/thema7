control = factor(rep(rep(1:3, each = 2), 1),
labels = c("con4279", "con4280", "con4280a")))
# Rownames for the annotation get taken from raw_data.
rownames(annotation) <- names(raw_data)
# Heatmap function gets called on the matrix and annotation objects.
pheatmap(sampleDistMatrix, show_colnames = FALSE,
annotation_col = annotation,
clustering_distance_rows = sampledists,
clustering_distance_cols = sampledists,
main = "Euclidean Sample Distances")
# Creating the objects required by ggplot for mds.
dds <- assay(ddsMat)
poisd <- PoissonDistance( t(dds), type = "deseq")
samplePoisDistMatrix <- as.matrix(poisd$dd)
mdsPoisData <- data.frame( cmdscale(samplePoisDistMatrix) )
# Creating names for the coords.
names(mdsPoisData) <- c('x_coord', 'y_coord')
# Getting the columns as factors.
groups <- factor(rep(1:6, each=1),
labels = names(raw_data))
# Column name extraction.
coldata <- names(raw_data)
# Plotting the distance data in a 2d plot with ggplot.
ggplot(mdsPoisData, aes(x_coord, y_coord, color = groups, label = coldata)) +
geom_text(size = 4) +
ggtitle('Multi Dimensional Scaling') +
labs(x = "Poisson Distance", y = "Poisson Distance") +
theme_bw()
# Applying the FPM calculation then creating a data frame out of it.
raw_data.fpm <- log2( (raw_data/ (colSums(raw_data) / 1e6 )) + 1)
# Make a column which sums up the log2 reads.
raw_data.fpm$sum = apply(X = raw_data.fpm, MARGIN = 1, FUN = sum)
# Calculating the percentage of genes with a total of 0 counts across all groups
sum(raw_data.fpm$sum == 0) / nrow(raw_data.fpm) * 100
sum(raw_data.fpm$sum > 0.5)
sum(raw_data.fpm$sum > 0.5) / nrow(raw_data.fpm) * 100
raw_data.fpm <- raw_data.fpm[raw_data.fpm$sum > 0.5,]
View(raw_data.fpm)
knitr::opts_chunk$set(echo = TRUE)
library(affy)
library(scales)
library(DESeq2)
library(pheatmap)
library(ggplot2)
library(PoiClaClu)
file <- c("..\\data\\GSE152262_RNAseq_Raw_Counts.tsv")
# Raw_Data will be the primary dataframe that gets worked on.
raw_data <- read.table(file, sep = '\t', header = TRUE, row.names = 1)
# The first two and single last columns are the case samples.
# Control samples are indicated with con.
colnames(raw_data) <- c("case24275", "case24277", "con4279", "con4280", "con4280a", "case24281")
# Rearranging the columns so that the first three are the case samples.
raw_data <- raw_data[, c(1,2,6,3,4,5)]
# Showing the first five rows as an example.
raw_data[1:5,]
# Showing the dimension and structure of the raw_data dataframe.
dim(raw_data)
str(raw_data)
# Transforming the read data of every columns to the log2 value
# 1 is added to every column to make sure there are no log2(0) values.
raw_data_log2 <- log2(raw_data + 1)
# Dividing the case and controls columns into seperate dataframes for later use.
case <- raw_data[,c(1:3)]
control <- raw_data[,c(3:6)]
# Applying the same division, but with the log values for plotting purposes.
case_log2 <- raw_data_log2[,c(1:3)]
control_log2 <- raw_data_log2[,c(4:6)]
# Displaying the first rows of divided dataframes.
case_log2[1,]
control_log2[1,]
# Applying a summary on all the log2 data.
summary(raw_data_log2)
# Getting the mean values of both controlled and case sample expression values
# For every gene. This might be useful later.
case_log2$mean = apply(X = case_log2[1:3], MARGIN = 1, FUN = mean)
control_log2$mean = apply(X = control_log2[1:3], MARGIN = 1, FUN = mean)
# Doing the same to the raw data frames.
case$mean = apply(X = case[1:3], MARGIN = 1, FUN = mean)
control$mean = apply(X = control[1:3], MARGIN = 1, FUN = mean)
# Plotting the log2 data.
boxplot(control_log2$mean, case_log2$m, outline = FALSE, names = c("control_log2 Mean", "case_log2 Mean"))
# Creating the recurring colors that will be used for the columns
myColors <- hue_pal()(6)
# Density plotting the log2 data, using the colors created above.
plotDensity(raw_data_log2, col=rep(myColors, each=1), lty=c(1:ncol(raw_data_log2)),
main = "Expression Distribution", xlab = "Log2(raw_data_log2 counts)")
# Adding a legend for clarity.
legend('topright', names(raw_data_log2), lty=c(1:ncol(raw_data_log2)),
col=rep(myColors, each=1))
# There are 5 rows which do not count for actual genes.
# These rows are currently not relevant, but shouldn't be present from now on.
remove_rows <- c("__not_aligned", "__no_feature", "__no_feature",
"__alignment_not_unique", "__too_low_aQual", "__ambiguous")
raw_data <- raw_data[!(row.names(raw_data) %in% remove_rows),]
# Bar plotting the new data. Division by 1e6 shows the values in millions.
barplot(colSums(raw_data) / 1e6, las = 2, cex.names = 0.8, col = myColors, xlab = "Genes", ylab = "Expression in millions")
# Creating the dds Matrix, so that it ca nbe used in the vst function
(ddsMat <- DESeqDataSetFromMatrix(countData = raw_data,
colData = data.frame(samples=names(raw_data)),
design = ~ 1))
# Applying vst and saving it into the rld.dds object.
rld.dds <- vst(ddsMat)
# Applying assay on that object then saving it into rld.
rld <- assay(rld.dds)
# To create the heatmap, distances first get calculated & stored in a matrix
sampledists <- dist( t( rld ))
sampleDistMatrix <- as.matrix(sampledists)
# Annotation dataframe gets created for heatmap.
annotation <- data.frame(case = factor(rep(1:3, each = 1),
labels = c("case24275", "case24277", "case24281")),
control = factor(rep(rep(1:3, each = 2), 1),
labels = c("con4279", "con4280", "con4280a")))
# Rownames for the annotation get taken from raw_data.
rownames(annotation) <- names(raw_data)
# Heatmap function gets called on the matrix and annotation objects.
pheatmap(sampleDistMatrix, show_colnames = FALSE,
annotation_col = annotation,
clustering_distance_rows = sampledists,
clustering_distance_cols = sampledists,
main = "Euclidean Sample Distances")
# Creating the objects required by ggplot for mds.
dds <- assay(ddsMat)
poisd <- PoissonDistance( t(dds), type = "deseq")
samplePoisDistMatrix <- as.matrix(poisd$dd)
mdsPoisData <- data.frame( cmdscale(samplePoisDistMatrix) )
# Creating names for the coords.
names(mdsPoisData) <- c('x_coord', 'y_coord')
# Getting the columns as factors.
groups <- factor(rep(1:6, each=1),
labels = names(raw_data))
# Column name extraction.
coldata <- names(raw_data)
# Plotting the distance data in a 2d plot with ggplot.
ggplot(mdsPoisData, aes(x_coord, y_coord, color = groups, label = coldata)) +
geom_text(size = 4) +
ggtitle('Multi Dimensional Scaling') +
labs(x = "Poisson Distance", y = "Poisson Distance") +
theme_bw()
# Applying the FPM calculation then creating a data frame out of it.
raw_data.fpm <- log2( (raw_data/ (colSums(raw_data) / 1e6 )) + 1)
# Make a column which sums up the log2 reads.
raw_data.fpm$sum = apply(X = raw_data.fpm, MARGIN = 1, FUN = sum)
# Calculating the percentage of genes with a total of 0 counts across all groups
sum(raw_data.fpm$sum == 0) / nrow(raw_data.fpm) * 100
sum(raw_data.fpm$sum > 0.5)
sum(raw_data.fpm$sum > 0.5) / nrow(raw_data.fpm) * 100
raw_data.fpm <- raw_data.fpm[raw_data.fpm$sum > 0.5,]
knitr::opts_chunk$set(echo = TRUE)
library(affy)
library(scales)
library(DESeq2)
library(pheatmap)
library(ggplot2)
library(PoiClaClu)
file <- c("..\\data\\GSE152262_RNAseq_Raw_Counts.tsv")
# Raw_Data will be the primary dataframe that gets worked on.
raw_data <- read.table(file, sep = '\t', header = TRUE, row.names = 1)
# The first two and single last columns are the case samples.
# Control samples are indicated with con.
colnames(raw_data) <- c("case24275", "case24277", "con4279", "con4280", "con4280a", "case24281")
# Rearranging the columns so that the first three are the case samples.
raw_data <- raw_data[, c(1,2,6,3,4,5)]
# Showing the first five rows as an example.
raw_data[1:5,]
# Showing the dimension and structure of the raw_data dataframe.
dim(raw_data)
str(raw_data)
# Transforming the read data of every columns to the log2 value
# 1 is added to every column to make sure there are no log2(0) values.
raw_data_log2 <- log2(raw_data + 1)
# Dividing the case and controls columns into seperate dataframes for later use.
case <- raw_data[,c(1:3)]
control <- raw_data[,c(3:6)]
# Applying the same division, but with the log values for plotting purposes.
case_log2 <- raw_data_log2[,c(1:3)]
control_log2 <- raw_data_log2[,c(4:6)]
# Displaying the first rows of divided dataframes.
case_log2[1,]
control_log2[1,]
# Applying a summary on all the log2 data.
summary(raw_data_log2)
# Getting the mean values of both controlled and case sample expression values
# For every gene. This might be useful later.
case_log2$mean = apply(X = case_log2[1:3], MARGIN = 1, FUN = mean)
control_log2$mean = apply(X = control_log2[1:3], MARGIN = 1, FUN = mean)
# Doing the same to the raw data frames.
case$mean = apply(X = case[1:3], MARGIN = 1, FUN = mean)
control$mean = apply(X = control[1:3], MARGIN = 1, FUN = mean)
# Plotting the log2 data.
boxplot(control_log2$mean, case_log2$m, outline = FALSE, names = c("control_log2 Mean", "case_log2 Mean"))
# Creating the recurring colors that will be used for the columns
myColors <- hue_pal()(6)
# Density plotting the log2 data, using the colors created above.
plotDensity(raw_data_log2, col=rep(myColors, each=1), lty=c(1:ncol(raw_data_log2)),
main = "Expression Distribution", xlab = "Log2(raw_data_log2 counts)")
# Adding a legend for clarity.
legend('topright', names(raw_data_log2), lty=c(1:ncol(raw_data_log2)),
col=rep(myColors, each=1))
# There are 5 rows which do not count for actual genes.
# These rows are currently not relevant, but shouldn't be present from now on.
remove_rows <- c("__not_aligned", "__no_feature", "__no_feature",
"__alignment_not_unique", "__too_low_aQual", "__ambiguous")
raw_data <- raw_data[!(row.names(raw_data) %in% remove_rows),]
# Bar plotting the new data. Division by 1e6 shows the values in millions.
barplot(colSums(raw_data) / 1e6, las = 2, cex.names = 0.8, col = myColors, xlab = "Genes", ylab = "Expression in millions")
# Creating the dds Matrix, so that it ca nbe used in the vst function
(ddsMat <- DESeqDataSetFromMatrix(countData = raw_data,
colData = data.frame(samples=names(raw_data)),
design = ~ 1))
# Applying vst and saving it into the rld.dds object.
rld.dds <- vst(ddsMat)
# Applying assay on that object then saving it into rld.
rld <- assay(rld.dds)
# To create the heatmap, distances first get calculated & stored in a matrix
sampledists <- dist( t( rld ))
sampleDistMatrix <- as.matrix(sampledists)
# Annotation dataframe gets created for heatmap.
annotation <- data.frame(case = factor(rep(1:3, each = 1),
labels = c("case24275", "case24277", "case24281")),
control = factor(rep(rep(1:3, each = 2), 1),
labels = c("con4279", "con4280", "con4280a")))
# Rownames for the annotation get taken from raw_data.
rownames(annotation) <- names(raw_data)
# Heatmap function gets called on the matrix and annotation objects.
pheatmap(sampleDistMatrix, show_colnames = FALSE,
annotation_col = annotation,
clustering_distance_rows = sampledists,
clustering_distance_cols = sampledists,
main = "Euclidean Sample Distances")
# Creating the objects required by ggplot for mds.
dds <- assay(ddsMat)
poisd <- PoissonDistance( t(dds), type = "deseq")
samplePoisDistMatrix <- as.matrix(poisd$dd)
mdsPoisData <- data.frame( cmdscale(samplePoisDistMatrix) )
# Creating names for the coords.
names(mdsPoisData) <- c('x_coord', 'y_coord')
# Getting the columns as factors.
groups <- factor(rep(1:6, each=1),
labels = names(raw_data))
# Column name extraction.
coldata <- names(raw_data)
# Plotting the distance data in a 2d plot with ggplot.
ggplot(mdsPoisData, aes(x_coord, y_coord, color = groups, label = coldata)) +
geom_text(size = 4) +
ggtitle('Multi Dimensional Scaling') +
labs(x = "Poisson Distance", y = "Poisson Distance") +
theme_bw()
# Applying the FPM calculation then creating a data frame out of it.
raw_data.fpm <- log2( (raw_data/ (colSums(raw_data) / 1e6 )) + 1)
# Make a column which sums up the log2 reads.
raw_data.fpm$sum = apply(X = raw_data.fpm, MARGIN = 1, FUN = sum)
# Calculating the percentage of genes with a total of 0 counts across all groups
sum(raw_data.fpm$sum == 0) / nrow(raw_data.fpm) * 100
sum(raw_data.fpm$sum > 0.5)
sum(raw_data.fpm$sum > 0.5) / nrow(raw_data.fpm) * 100
raw_data.fpm <- raw_data.fpm[raw_data.fpm$sum > 0.5,]
View(raw_data.fpm)
raw_data.fpm$case_avg <- mean(raw_data.fpm[,1:3])
raw_data.fpm$case_avg <- mean(raw_data.fpm[1:3,])
raw_data.fpm$case_avg = apply(X = raw_data.fpm[,1:3], MARGIN = 1, FUN = mean)
raw_data.fpm$case_avg = apply(X = raw_data.fpm[,1:3], MARGIN = 1, FUN = mean)
raw_data.fpm$con_avg = apply(X = raw_data.fpm[,4:6], MARGIN = 1, FUN = mean)
knitr::opts_chunk$set(echo = TRUE)
library(affy)
library(scales)
library(DESeq2)
library(pheatmap)
library(ggplot2)
library(PoiClaClu)
file <- c("..\\data\\GSE152262_RNAseq_Raw_Counts.tsv")
# Raw_Data will be the primary dataframe that gets worked on.
raw_data <- read.table(file, sep = '\t', header = TRUE, row.names = 1)
# The first two and single last columns are the case samples.
# Control samples are indicated with con.
colnames(raw_data) <- c("case24275", "case24277", "con4279", "con4280", "con4280a", "case24281")
# Rearranging the columns so that the first three are the case samples.
raw_data <- raw_data[, c(1,2,6,3,4,5)]
# Showing the first five rows as an example.
raw_data[1:5,]
# Showing the dimension and structure of the raw_data dataframe.
dim(raw_data)
str(raw_data)
# Transforming the read data of every columns to the log2 value
# 1 is added to every column to make sure there are no log2(0) values.
raw_data_log2 <- log2(raw_data + 1)
# Dividing the case and controls columns into seperate dataframes for later use.
case <- raw_data[,c(1:3)]
control <- raw_data[,c(3:6)]
# Applying the same division, but with the log values for plotting purposes.
case_log2 <- raw_data_log2[,c(1:3)]
control_log2 <- raw_data_log2[,c(4:6)]
# Displaying the first rows of divided dataframes.
case_log2[1,]
control_log2[1,]
# Applying a summary on all the log2 data.
summary(raw_data_log2)
# Getting the mean values of both controlled and case sample expression values
# For every gene. This might be useful later.
case_log2$mean = apply(X = case_log2[1:3], MARGIN = 1, FUN = mean)
control_log2$mean = apply(X = control_log2[1:3], MARGIN = 1, FUN = mean)
# Doing the same to the raw data frames.
case$mean = apply(X = case[1:3], MARGIN = 1, FUN = mean)
control$mean = apply(X = control[1:3], MARGIN = 1, FUN = mean)
# Plotting the log2 data.
boxplot(control_log2$mean, case_log2$m, outline = FALSE, names = c("control_log2 Mean", "case_log2 Mean"))
# Creating the recurring colors that will be used for the columns
myColors <- hue_pal()(6)
# Density plotting the log2 data, using the colors created above.
plotDensity(raw_data_log2, col=rep(myColors, each=1), lty=c(1:ncol(raw_data_log2)),
main = "Expression Distribution", xlab = "Log2(raw_data_log2 counts)")
# Adding a legend for clarity.
legend('topright', names(raw_data_log2), lty=c(1:ncol(raw_data_log2)),
col=rep(myColors, each=1))
# There are 5 rows which do not count for actual genes.
# These rows are currently not relevant, but shouldn't be present from now on.
remove_rows <- c("__not_aligned", "__no_feature", "__no_feature",
"__alignment_not_unique", "__too_low_aQual", "__ambiguous")
raw_data <- raw_data[!(row.names(raw_data) %in% remove_rows),]
# Bar plotting the new data. Division by 1e6 shows the values in millions.
barplot(colSums(raw_data) / 1e6, las = 2, cex.names = 0.8, col = myColors, xlab = "Genes", ylab = "Expression in millions")
# Creating the dds Matrix, so that it ca nbe used in the vst function
(ddsMat <- DESeqDataSetFromMatrix(countData = raw_data,
colData = data.frame(samples=names(raw_data)),
design = ~ 1))
# Applying vst and saving it into the rld.dds object.
rld.dds <- vst(ddsMat)
# Applying assay on that object then saving it into rld.
rld <- assay(rld.dds)
# To create the heatmap, distances first get calculated & stored in a matrix
sampledists <- dist( t( rld ))
sampleDistMatrix <- as.matrix(sampledists)
# Annotation dataframe gets created for heatmap.
annotation <- data.frame(case = factor(rep(1:3, each = 1),
labels = c("case24275", "case24277", "case24281")),
control = factor(rep(rep(1:3, each = 2), 1),
labels = c("con4279", "con4280", "con4280a")))
# Rownames for the annotation get taken from raw_data.
rownames(annotation) <- names(raw_data)
# Heatmap function gets called on the matrix and annotation objects.
pheatmap(sampleDistMatrix, show_colnames = FALSE,
annotation_col = annotation,
clustering_distance_rows = sampledists,
clustering_distance_cols = sampledists,
main = "Euclidean Sample Distances")
# Creating the objects required by ggplot for mds.
dds <- assay(ddsMat)
poisd <- PoissonDistance( t(dds), type = "deseq")
samplePoisDistMatrix <- as.matrix(poisd$dd)
mdsPoisData <- data.frame( cmdscale(samplePoisDistMatrix) )
# Creating names for the coords.
names(mdsPoisData) <- c('x_coord', 'y_coord')
# Getting the columns as factors.
groups <- factor(rep(1:6, each=1),
labels = names(raw_data))
# Column name extraction.
coldata <- names(raw_data)
# Plotting the distance data in a 2d plot with ggplot.
ggplot(mdsPoisData, aes(x_coord, y_coord, color = groups, label = coldata)) +
geom_text(size = 4) +
ggtitle('Multi Dimensional Scaling') +
labs(x = "Poisson Distance", y = "Poisson Distance") +
theme_bw()
# Applying the FPM calculation then creating a data frame out of it.
raw_data.fpm <- log2( (raw_data/ (colSums(raw_data) / 1e6 )) + 1)
# Make a column which sums up the log2 reads.
raw_data.fpm$sum = apply(X = raw_data.fpm, MARGIN = 1, FUN = sum)
# Calculating the percentage of genes with a total of 0 counts across all groups
sum(raw_data.fpm$sum == 0) / nrow(raw_data.fpm) * 100
sum(raw_data.fpm$sum > 0.5)
sum(raw_data.fpm$sum > 0.5) / nrow(raw_data.fpm) * 100
raw_data.fpm <- raw_data.fpm[raw_data.fpm$sum > 0.5,]
# Calculating the means and savin them in columns
raw_data.fpm$case_avg = apply(X = raw_data.fpm[,1:3], MARGIN = 1, FUN = mean)
raw_data.fpm$con_avg = apply(X = raw_data.fpm[,4:6], MARGIN = 1, FUN = mean)
# Calculating the LFC values.
raw_data.fpm$lfc = raw_data.fpm$case_avg - raw_data.fpm$con_avg
hist(raw_data.fpm$lfc, breaks = 60)
knitr::opts_chunk$set(echo = TRUE)
library(affy)
library(scales)
library(DESeq2)
library(pheatmap)
library(ggplot2)
library(PoiClaClu)
file <- c("..\\data\\GSE152262_RNAseq_Raw_Counts.tsv")
# Raw_Data will be the primary dataframe that gets worked on.
raw_data <- read.table(file, sep = '\t', header = TRUE, row.names = 1)
# The first two and single last columns are the case samples.
# Control samples are indicated with con.
colnames(raw_data) <- c("case24275", "case24277", "con4279", "con4280", "con4280a", "case24281")
# Rearranging the columns so that the first three are the case samples.
raw_data <- raw_data[, c(1,2,6,3,4,5)]
# Showing the first five rows as an example.
raw_data[1:5,]
# Showing the dimension and structure of the raw_data dataframe.
dim(raw_data)
str(raw_data)
# Transforming the read data of every columns to the log2 value
# 1 is added to every column to make sure there are no log2(0) values.
raw_data_log2 <- log2(raw_data + 1)
# Dividing the case and controls columns into seperate dataframes for later use.
case <- raw_data[,c(1:3)]
control <- raw_data[,c(3:6)]
# Applying the same division, but with the log values for plotting purposes.
case_log2 <- raw_data_log2[,c(1:3)]
control_log2 <- raw_data_log2[,c(4:6)]
# Displaying the first rows of divided dataframes.
case_log2[1,]
control_log2[1,]
# Applying a summary on all the log2 data.
summary(raw_data_log2)
# Getting the mean values of both controlled and case sample expression values
# For every gene. This might be useful later.
case_log2$mean = apply(X = case_log2[1:3], MARGIN = 1, FUN = mean)
control_log2$mean = apply(X = control_log2[1:3], MARGIN = 1, FUN = mean)
# Doing the same to the raw data frames.
case$mean = apply(X = case[1:3], MARGIN = 1, FUN = mean)
control$mean = apply(X = control[1:3], MARGIN = 1, FUN = mean)
# Plotting the log2 data.
boxplot(control_log2$mean, case_log2$m, outline = FALSE, names = c("control_log2 Mean", "case_log2 Mean"))
# Creating the recurring colors that will be used for the columns
myColors <- hue_pal()(6)
# Density plotting the log2 data, using the colors created above.
plotDensity(raw_data_log2, col=rep(myColors, each=1), lty=c(1:ncol(raw_data_log2)),
main = "Expression Distribution", xlab = "Log2(raw_data_log2 counts)")
# Adding a legend for clarity.
legend('topright', names(raw_data_log2), lty=c(1:ncol(raw_data_log2)),
col=rep(myColors, each=1))
# There are 5 rows which do not count for actual genes.
# These rows are currently not relevant, but shouldn't be present from now on.
remove_rows <- c("__not_aligned", "__no_feature", "__no_feature",
"__alignment_not_unique", "__too_low_aQual", "__ambiguous")
raw_data <- raw_data[!(row.names(raw_data) %in% remove_rows),]
# Bar plotting the new data. Division by 1e6 shows the values in millions.
barplot(colSums(raw_data) / 1e6, las = 2, cex.names = 0.8, col = myColors, xlab = "Genes", ylab = "Expression in millions")
# Creating the dds Matrix, so that it ca nbe used in the vst function
(ddsMat <- DESeqDataSetFromMatrix(countData = raw_data,
colData = data.frame(samples=names(raw_data)),
design = ~ 1))
# Applying vst and saving it into the rld.dds object.
rld.dds <- vst(ddsMat)
# Applying assay on that object then saving it into rld.
rld <- assay(rld.dds)
# To create the heatmap, distances first get calculated & stored in a matrix
sampledists <- dist( t( rld ))
sampleDistMatrix <- as.matrix(sampledists)
# Annotation dataframe gets created for heatmap.
annotation <- data.frame(case = factor(rep(1:3, each = 1),
labels = c("case24275", "case24277", "case24281")),
control = factor(rep(rep(1:3, each = 2), 1),
labels = c("con4279", "con4280", "con4280a")))
# Rownames for the annotation get taken from raw_data.
rownames(annotation) <- names(raw_data)
# Heatmap function gets called on the matrix and annotation objects.
pheatmap(sampleDistMatrix, show_colnames = FALSE,
annotation_col = annotation,
clustering_distance_rows = sampledists,
clustering_distance_cols = sampledists,
main = "Euclidean Sample Distances")
# Creating the objects required by ggplot for mds.
dds <- assay(ddsMat)
poisd <- PoissonDistance( t(dds), type = "deseq")
samplePoisDistMatrix <- as.matrix(poisd$dd)
mdsPoisData <- data.frame( cmdscale(samplePoisDistMatrix) )
# Creating names for the coords.
names(mdsPoisData) <- c('x_coord', 'y_coord')
# Getting the columns as factors.
groups <- factor(rep(1:6, each=1),
labels = names(raw_data))
# Column name extraction.
coldata <- names(raw_data)
# Plotting the distance data in a 2d plot with ggplot.
ggplot(mdsPoisData, aes(x_coord, y_coord, color = groups, label = coldata)) +
geom_text(size = 4) +
ggtitle('Multi Dimensional Scaling') +
labs(x = "Poisson Distance", y = "Poisson Distance") +
theme_bw()
# Applying the FPM calculation then creating a data frame out of it.
raw_data.fpm <- log2( (raw_data/ (colSums(raw_data) / 1e6 )) + 1)
# Make a column which sums up the log2 reads.
raw_data.fpm$sum = apply(X = raw_data.fpm, MARGIN = 1, FUN = sum)
# Calculating the percentage of genes with a total of 0 counts across all groups
sum(raw_data.fpm$sum == 0) / nrow(raw_data.fpm) * 100
sum(raw_data.fpm$sum > 0.5)
sum(raw_data.fpm$sum > 0.5) / nrow(raw_data.fpm) * 100
raw_data.fpm <- raw_data.fpm[raw_data.fpm$sum > 0.5,]
# Calculating the means and savin them in columns
raw_data.fpm$case_avg = apply(X = raw_data.fpm[,1:3], MARGIN = 1, FUN = mean)
raw_data.fpm$con_avg = apply(X = raw_data.fpm[,4:6], MARGIN = 1, FUN = mean)
# Calculating the LFC values.
raw_data.fpm$lfc = raw_data.fpm$case_avg - raw_data.fpm$con_avg
hist(raw_data.fpm$lfc, breaks = 20)
hist(raw_data.fpm$lfc)
hist(raw_data.fpm$lfc)
hist(raw_data.fpm$lfc, breaks = 50)
hist(raw_data.fpm$lfc, breaks = 100)
hist(raw_data.fpm$lfc, breaks = 5000)
hist(raw_data.fpm$lfc, breaks = 40)
hist(raw_data.fpm$lfc, breaks = 210)
hist(raw_data.fpm$lfc, breaks = 120)
hist(raw_data.fpm$lfc, breaks = 80)
hist(raw_data.fpm$lfc, breaks = 50)
hist(raw_data.fpm$lfc, breaks = 50)
hist(raw_data.fpm$lfc, breaks = 60)
hist(raw_data.fpm$lfc, breaks = 60)
abline(v = 0)
hist(raw_data.fpm$lfc, breaks = 60)
abline(v = -1:1)
View(raw_data)
BiocManager::install("edgeR")
.libPaths()
BiocManager::install("edgeR")
